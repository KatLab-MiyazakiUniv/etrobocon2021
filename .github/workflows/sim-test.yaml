name: Simulator Test

on: [pull_request]

jobs:
  build-check:
    runs-on: ubuntu-20.04
    env:
      IMAGE: github-actions-etrobocon2021
      APP_NAME: etrobocon2021

    steps:
      # ${{ github.workspace }} を使用するために必要
      - name: Checkout
        uses: actions/checkout@v2

      # ログイン
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v1
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Docker image を GitHub Container Registry から Pull して、
      # 実際に etrobo 環境でのビルドが実行できるかどうか確認する
      # https://docs.github.com/ja/packages/working-with-a-github-packages-registry/working-with-the-container-registry
      - name: ETRobocon build test
        run: |
          docker run -e APP_NAME=${{ env.APP_NAME }} \
                     -v ${{ github.workspace }}:/tmp/${{ env.APP_NAME }}:rw \
                     ghcr.io/katlab-miyazakiuniv/${{ env.IMAGE }}:latest

  simulator-test:
    runs-on: self-hosted
    needs: build-check
    env:
      ETROBO_ROOT: /home/etrobocon2021/etrobo
      SIM_LOG_FILE: sim-log.txt
      MP4_SERVER_NAME: etrobocon2021.moyashi.dev
      MAX_SIM_TIME: 20
      APP_NAME: etrobocon2021

    steps:
    - uses: actions/checkout@v2

    # シミュレータテストのための下準備
    - name: Set up simulator
      shell: bash
      run: |
        # もし、etrobocon2021 ディレクトリが既に存在する場合は削除
        etrobo_cmd=''
        etrobo_cmd+='if [ -d ${ETROBO_HRP3_WOKSPACE}/${{ env.APP_NAME }} ]; then rm -rf ${ETROBO_HRP3_WORKSPACE}/${{ env.APP_NAME }}; fi; '

        # etrobo環境に、etrobocon2021リポジトリへのシンボリックリンクを作成
        etrobo_cmd+='ln -s ${{ github.workspace }} ${ETROBO_HRP3_WORKSPACE}/${{ env.APP_NAME }}; '

        # etrobo環境で上述のコマンドを実行
        echo ${etrobo_cmd} | ${HOME}/startetrobo shell

    # シミュレータを研究室のPCで実行する
    - name: Test on simulator
      shell: bash
      run: |
        # 初期コメントの生成
        msg_result=""
        msg_result+="## 結果\n"
        msg_result+="|No|コース|走行タイム [s]|ボーナスタイム [s]|リザルトタイム [s]|ブロック配置|動画|\n"
        msg_result+="|--|-----|-------------|----------------|-----------------|-----------|----|\n"

        msg_detail=""
        msg_detail+="<details>\n"
        msg_detail+="<summary>詳細を表示</summary>\n"
        msg_detail+="\n"
        msg_detail+="|No|スタートゲート通過|ゲート1通過|ゲート2通過|走行タイム [s]|ブロックサークル有効移動|パワースポット有効移動|センターブロック有効移動|ビンゴ|パワースポットビンゴ|ボーナスタイム[s]|リザルトタイム[s]|ブロック配置|MP4|CSV|LOG|settings.json|\n"
        msg_detail+="|--|---------------|---------|---------|-------------|-------------------|-------------------|-------------------|------|----------------|--------------|--------------|----------|---|---|---|-------------|\n"

        msg_detail_tail="</details>\n\n"

        msg_summary_head=""
        msg_summary_head+="### 集計結果\n"

        msg_summary_detail_head=""
        msg_summary_detail_head+="<details>\n"
        msg_summary_detail_head+="<summary>詳細を表示</summary>\n\n"
        msg_summary_detail_tail="</details>\n\n"
        msg_summary_detail_head+="|項目|結果|母数|\n"
        msg_summary_detail_head+="|---|----|---|\n"

        msg_tail=":arrows_counterclockwise: Now testing... (1/${MAX_SIM_TIME})"

        # プルリクの Issue 番号の取得 (on: pull_request のイベントによってトリガーされた場合のみ)
        ISSUE_NUMBER=$(jq --raw-output .pull_request.number "${GITHUB_EVENT_PATH}")

        # このプルリクに新たなコミットがPushされていることを検知した場合、テストをスキップする
        IS_SKIP=$(curl -H "Accept: application/vnd.github.v3+json" \
                       ${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/actions/runs?status=queued\&per_page=99 | \
                    jq '.workflow_runs[] | select(.pull_requests != null) | .pull_requests[].number' | \
                    grep -oE ${ISSUE_NUMBER} | wc -l)
        if [ "${IS_SKIP}" != "0" ]; then
          msg_tail=":fast_forward: Skiped"
        fi

        # プルリクコメントの投稿とコメントIDの取得
        COMMENT_ID=$(curl \
                      -X POST \
                      -H "Accept: application/vnd.github.v3+json" \
                      -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                      ${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}/comments \
                      -d "{\"body\":\"${msg_tail}\"}" | jq -r '.id')

        # シミュレータテストのスキップ
        if [ "${IS_SKIP}" != "0" ]; then
          msg_tail=":fast_forward: Skiped"
        fi

        # テスト結果公開用ディレクトリの生成
        TEST_RESULT_DIR_ROOT=${HOME}/Videos
        TEST_RESULT_DIR=results/$(date '+%Y-%m-%d/%H-%M-%S')
        mkdir -p ${TEST_RESULT_DIR_ROOT}/${TEST_RESULT_DIR}

        # 集計用変数
        l_counter=0
        l_goal_counter=0
        l_goal_time_sum=0
        l_bonus_time_sum=0
        l_result_time_sum=0  # NOTE: 無くても良いが有ったほうが楽

        r_counter=0
        r_goal_counter=0
        r_goal_time_sum=0
        r_bonus_time_sum=0
        r_result_time_sum=0  # NOTE: 無くても良いが有ったほうが楽

        best_result_time=120

        ###  シミュレーションを複数回実行する。　　　　　　　　　　　　　　　　　　　###
        ###  他のシミュレーションテストのリクエストが発生した場合、　　　　　　　　　###
        ###  実行中のシミュレーションが終了次第、シミュレーションテストを終了する。　###
        for ((i=1; i<=${MAX_SIM_TIME}; i++)); do
          # キャプチャ画像用一時ディレクトリの生成
          tmp_capture_dir=$(mktemp -d)
          echo ${tmp_capture_dir}

          # 初期ブロック配置をランダムに生成
          block_coordinate_l='09'$(echo "from random import *; print(''.join(sample('EMBKDRGP',8)))" | python3)
          block_coordinate_r='09'$(echo "from random import *; print(''.join(sample('HJCLAQFS',8)))" | python3)

          # シミュレータの設定ファイルを生成
          settings_file=${TEST_RESULT_DIR}/${GITHUB_SHA}-${i}.json
          cat ${GITHUB_WORKSPACE}/sim-settings/default.json | \
            jq ".captureDir=\"${tmp_capture_dir}\"" | \
            jq ".captureRate=\"2\"" | \
            jq ".initLBlockLayout=\"${block_coordinate_l}\"" | \
            jq ".initRBlockLayout=\"${block_coordinate_r}\"" > ${TEST_RESULT_DIR_ROOT}/${settings_file}

          # シミュレータに設定ファイルを反映させる
          curl -X POST \
              -H "Content-Type: application/json" \
              -d @${TEST_RESULT_DIR_ROOT}/${settings_file} \
              http://localhost:54000

          # 走行コースの設定
          a=('r' 'l')
          course_lower=${a[$(( i % 2))]}
          course_upper=$(echo ${course_lower} | tr lr LR)

          # シミュレーションの実行
          log_file=${TEST_RESULT_DIR}/${GITHUB_SHA}-${i}.log
          echo "make ${course_lower} app=${APP_NAME} sim up" | \
            ${HOME}/startetrobo shell | \
            tee ${TEST_RESULT_DIR_ROOT}/${log_file}

          # CSVファイルのコピー
          csv_file=${TEST_RESULT_DIR}/${GITHUB_SHA}-${i}.csv
          cp ${tmp_capture_dir}/${course_upper}.csv \
            ${TEST_RESULT_DIR_ROOT}/${csv_file}

          # スタート前に撮影されたキャプチャ画像を削除する。
          # 一番最後のフレームが消えることになるが、
          # ゴール後 1 フレーム以上のキャプチャ画像が生成されるため、
          # 問題は無いと判断。
          csv_tail_num=$(cat ${TEST_RESULT_DIR_ROOT}/${csv_file} | \
                            tail -n1 | \
                            sed -r 's/.*(L|R)_([0-9]{8})\.png.*/\2/g')
          png_tail_num=$(ls ${tmp_capture_dir}/*.png | \
                            tail -n1 | \
                            sed -r 's/.*(L|R)_([0-9]{8})\.png/\2/g')
          echo "echo ${tmp_capture_dir}/${course_upper}_{${csv_tail_num}..${png_tail_num}}.png" | bash | xargs -L1 rm -f

          # キャプチャ画像をMP4に変換
          mp4_file=${TEST_RESULT_DIR}/${GITHUB_SHA}-${i}.mp4
          ffmpeg -y \
                -framerate 30 \
                -i ${tmp_capture_dir}/$(echo ${course_lower} | tr lr LR)_%08d.png \
                -vcodec libx264 -pix_fmt yuv420p \
                -r 30 ${TEST_RESULT_DIR_ROOT}/${mp4_file}

          # CSV ファイルを JSON ファイルに変換する
          # (Windows環境で生成されたCSVを変換する場合、OSの差異による改行文字の違いに注意)
          jq --compact-output -s -R 'split("\n")|map(split(","))|map({
              "Time": .[0], 
              "Counter": .[1], 
              "Filename": .[2], 
              "TIME": .[3], 
              "MEASUREMENT_TIME": .[4], 
              "RUN_TIME": .[5], 
              "GATE1": .[6], 
              "GATE2": .[7], 
              "GOAL": .[8], 
              "GARAGE_STOP": .[9], 
              "GARAGE_TIME": .[10], 
              "SLALOM": .[11], 
              "PETBOTTLE": .[12], 
              "BLOCK_IN_GARAGE": .[13], 
              "BLOCK_YUKOIDO": .[14], 
              "CARD_NUMBER_CIRCLE": .[15], 
              "BLOCK_NUMBER_CIRCLE": .[16], 
              "BLOCK_BINGO": .[17], 
              "ENTRY_BONUS": .[18], 
              "BLOCK_YUKOIDOP": .[19], 
              "BLOCK_YUKOIDOC": .[20], 
              "BLOCK_BINGOP": .[21], 
              "MeasurementMode": .[22]
            })' ${TEST_RESULT_DIR_ROOT}/${csv_file} > ${TEST_RESULT_DIR_ROOT}/${csv_file}.json

          # ビンゴエリアの結果を一時保存するためのJSONファイルを生成
          tmp_json_file=$(mktemp --suffix=.json)
          echo ${tmp_json_file}

          # ビンゴエリアの最終結果を抽出し、一時ファイルに保存
          cat ${TEST_RESULT_DIR_ROOT}/${csv_file}.json | \
            jq '.[] | select(.MeasurementMode=="END")' | \
            jq -s '.' | \
            jq 'max_by(.TIME)' > ${tmp_json_file}

          # ビンゴエリアの最終結果を集計する
          block_yukoido=$(jq -r '.BLOCK_YUKOIDO' ${tmp_json_file})
          power_spot_yukoido=$(jq -r '.BLOCK_YUKOIDOP' ${tmp_json_file})
          center_block_yukoido=$(jq -r '.BLOCK_YUKOIDOC' ${tmp_json_file})
          block_bingo=$(jq -r '.BLOCK_BINGO' ${tmp_json_file})
          powers_pot_bingo=$(jq -r '.BLOCK_BINGOP' ${tmp_json_file})

          # ボーナスタイムの計算
          block_yukoido_bonus_time=$(echo ${block_yukoido} | awk '{print $1 / 2}')
          power_spot_yukoido_bonus_time=${power_spot_yukoido}
          center_block_yukoido_bonus_time=$(echo ${center_block_yukoido} | awk '{print $1 * 2}')
          block_bingo_bonus_time=${block_bingo}
          power_spot_bingo_bonus_time=$(echo ${powers_pot_bingo} | awk '{print $1 * 2}')
          bonus_time=$(echo ${block_yukoido_bonus_time} \
                            ${power_spot_yukoido_bonus_time} \
                            ${center_block_yukoido_bonus_time} \
                            ${block_bingo_bonus_time} \
                            ${power_spot_bingo_bonus_time} \
                            | awk '{print $1 + $2 + $3 + $4 + $5}')

          # 各ゲートを通過したかどうかの確認
          passed_start_gate=$(cat ${TEST_RESULT_DIR_ROOT}/${log_file} | \
                              grep -coE '\[ launcher: ((left)|(right)): passed Start Gate \]' || :)
          passed_gate_1=$(cat ${TEST_RESULT_DIR_ROOT}/${log_file} | \
                              grep -coE '\[ launcher: ((left)|(right)): passed Gate 1 \]' || :)
          passed_gate_2=$(cat ${TEST_RESULT_DIR_ROOT}/${log_file} | \
                              grep -coE '\[ launcher: ((left)|(right)): passed Gate 2 \]' || :)
          passed_gale_gate=$(cat ${TEST_RESULT_DIR_ROOT}/${log_file} | \
                              grep -coE '\[ launcher: ((left)|(right)): GOAL!  Goal Time: ([0-9]*\.?[0-9]*) \]' || :)

          # 走行時間の取得 (ゴールゲートの通過)、リザルトタイムの算出
          if [ "${passed_gale_gate}" == '0' ]; then
            goal_time='None'
            result_time='None'
          else
            goal_time="$(cat ${TEST_RESULT_DIR_ROOT}/${log_file} | \
                          grep -oE '\[ launcher: ((left)|(right)): GOAL!  Goal Time: ([0-9]*\.?[0-9]*) \]' | \
                          grep -oE '[0-9]*\.?[0-9]*')"
            
            # リザルトタイムの計算
            result_time=$(echo ${goal_time} ${bonus_time} | awk '{print $1 - $2}')

            # ベストタイムの更新
            if [ "$(echo "${result_time} < ${best_result_time}" | bc)" -eq 1 ]; then
              best_result_time=${result_time}
            fi

            # 集計用変数の更新
            if [ "${course_upper}" == "L" ]; then
              l_goal_time_sum=$(echo ${l_goal_time_sum} ${goal_time} | awk '{print $1 + $2}')
              l_bonus_time_sum=$(echo ${l_bonus_time_sum} ${bonus_time} | awk '{print $1 + $2}')
              l_result_time_sum=$(echo ${l_result_time_sum} ${result_time} | awk '{print $1 + $2}')
              echo $(( l_goal_counter++ ))
            elif [ "${course_upper}" == "R" ]; then
              r_goal_time_sum=$(echo ${r_goal_time_sum} ${goal_time} | awk '{print $1 + $2}')
              r_bonus_time_sum=$(echo ${r_bonus_time_sum} ${bonus_time} | awk '{print $1 + $2}')
              r_result_time_sum=$(echo ${r_result_time_sum} ${result_time} | awk '{print $1 + $2}')
              echo $(( r_goal_counter++ ))
            fi
          fi

          # 走行回数カウンターの更新
          if [ "${course_upper}" == "L" ]; then
            echo $(( l_counter++ ))
          elif [ "${course_upper}" == "R" ]; then
            echo $(( r_counter++ ))
          fi

          # コメント用集計結果の計算
          l_goal_rate=$(echo ${l_goal_counter} ${l_counter} | awk '{if($2>0){print $1 / $2 * 100}else{print 0}}')
          r_goal_rate=$(echo ${r_goal_counter} ${r_counter} | awk '{if($2>0){print $1 / $2 * 100}else{print 0}}')
          lr_goal_rate=$(echo ${l_goal_counter} ${r_goal_counter} ${i} | awk '{if($3>0){print ($1 + $2) / $3 * 100}else{print 0}}')
          l_goal_time_avg=$(echo ${l_goal_time_sum} ${l_goal_counter} | awk '{if($2>0){print $1 / $2}else{print 0}}')
          r_goal_time_avg=$(echo ${r_goal_time_sum} ${r_goal_counter} | awk '{if($2>0){print $1 / $2}else{print 0}}')
          lr_goal_time_avg=$(echo ${l_goal_time_sum} ${r_goal_time_sum} ${l_goal_counter} ${r_goal_counter} | \
                              awk '{if(($3+$4)>0){print ($1 + $2) / ($3 + $4)}else{print 0}}')
          l_bonus_time_avg=$(echo ${l_bonus_time_sum} ${l_goal_counter} | awk '{if($2>0){print $1 / $2}else{print 0}}')
          r_bonus_time_avg=$(echo ${r_bonus_time_sum} ${r_goal_counter} | awk '{if($2>0){print $1 / $2}else{print 0}}')
          lr_bonus_time_avg=$(echo ${l_bonus_time_sum} ${r_bonus_time_sum} ${l_goal_counter} ${r_goal_counter} | \
                              awk '{if(($3+$4)>0){print ($1 + $2) / ($3 + $4)}else{print 0}}')
          l_result_time_avg=$(echo ${l_result_time_sum} ${l_goal_counter} | awk '{if($2>0){print $1 / $2}else{print 0}}')
          r_result_time_avg=$(echo ${r_result_time_sum} ${r_goal_counter} | awk '{if($2>0){print $1 / $2}else{print 0}}')
          lr_result_time_avg=$(echo ${l_result_time_sum} ${r_result_time_sum} ${l_goal_counter} ${r_goal_counter} | \
                              awk '{if(($3+$4)>0){print ($1 + $2) / ($3 + $4)}else{print 0}}')

          # コメントの作成
          msg_result+="|${i}|${course_upper}|${goal_time}|${bonus_time}|${result_time}|"
          msg_detail+="|${i}|${passed_start_gate}|${passed_gate_1}|${passed_gate_2}|${goal_time}"
          msg_detail+="|${block_yukoido_bonus_time}|${power_spot_yukoido_bonus_time}"
          msg_detail+="|${center_block_yukoido_bonus_time}|${block_bingo_bonus_time}"
          msg_detail+="|${power_spot_bingo_bonus_time}|${bonus_time}|${result_time}|"
          if [ "${course_upper}" == "L" ]; then
            msg_result+="${block_coordinate_l}|"
            msg_detail+="${block_coordinate_l}|"
          elif [ "${course_upper}" == "R" ]; then
            msg_result+="${block_coordinate_r}|"
            msg_detail+="${block_coordinate_r}|"
          fi
          msg_result+="[:arrow_forward: 動画](https://${MP4_SERVER_NAME}/01/${mp4_file})|\n"
          msg_detail+="[MP4](https://${MP4_SERVER_NAME}/01/${mp4_file})|"
          msg_detail+="[CSV](https://${MP4_SERVER_NAME}/01/${csv_file})|"
          msg_detail+="[LOG](https://${MP4_SERVER_NAME}/01/${log_file})|"
          msg_detail+="[JSON](https://${MP4_SERVER_NAME}/01/${settings_file})|\n"
          

          msg_summary=""
          msg_summary+="全体ゴール率: ${lr_goal_rate} [%] (n = ${i})\n"
          msg_summary+="全体平均リザルトタイム: ${lr_result_time_avg} [S] (n = $((l_goal_counter + r_goal_counter)))\n"
          msg_summary+="最速リザルトタイム: ${best_result_time} [S]\n"

          msg_summary_detail=""
          msg_summary_detail+="|Lゴール率[%]|${l_goal_rate}|${l_counter}|\n"
          msg_summary_detail+="|Rゴール率[%]|${r_goal_rate}|${r_counter}|\n"
          msg_summary_detail+="|全体ゴール率[%]|${lr_goal_rate}|$((l_counter + r_counter))|\n"
          msg_summary_detail+="| | | |\n"
          msg_summary_detail+="|L平均ゴールタイム[S]|${l_goal_time_avg}|${l_goal_counter}|\n"
          msg_summary_detail+="|R平均ゴールタイム[S]|${r_goal_time_avg}|${r_goal_counter}|\n"
          msg_summary_detail+="|全体平均ゴールタイム[S]|${lr_goal_time_avg}|$((l_goal_counter + r_goal_counter))|\n"
          msg_summary_detail+="| | | |\n"
          msg_summary_detail+="|L平均ボーナスタイム[S]|${l_bonus_time_avg}|${l_goal_counter}|\n"
          msg_summary_detail+="|R平均ボーナスタイム[S]|${r_bonus_time_avg}|${r_goal_counter}|\n"
          msg_summary_detail+="|全体平均ボーナスタイム[S]|${lr_bonus_time_avg}|$((l_goal_counter + r_goal_counter))|\n"
          msg_summary_detail+="| | | |\n"
          msg_summary_detail+="|L平均リザルトタイム[S]|${l_result_time_avg}|${l_goal_counter}|\n"
          msg_summary_detail+="|R平均リザルトタイム[S]|${r_result_time_avg}|${r_goal_counter}|\n"
          msg_summary_detail+="|平均リザルトタイム[S]|${lr_result_time_avg}|$((l_goal_counter + r_goal_counter))|\n"

          msg_tail=":arrows_counterclockwise: Now testing... ($((i + 1))/${MAX_SIM_TIME})"

          # 待ち状態になっているジョブ？が無いか確認する
          queued_job_num=$(curl -H "Accept: application/vnd.github.v3+json" \
                                ${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/actions/runs?status=queued\&per_page=99 | \
                              jq ".workflow_runs[] | select( .name == \"${GITHUB_WORKFLOW}\" ) | .id" | \
                              wc -l)

          # ループ終了時の片づけ
          if [[ "${i}" == "${MAX_SIM_TIME}" || "${queued_job_num}" != "0" ]]; then
            msg_tail=":white_check_mark: Test complete !!!"
            i=${MAX_SIM_TIME}
          fi

          # プルリクコメントのアップデート
          msg=''
          msg+="${msg_result}${msg_detail}${msg_detail_tail}${msg_summary_head}${msg_summary}"
          msg+="${msg_summary_detail_head}${msg_summary_detail}${msg_summary_detail_tail}${msg_tail}"
          curl \
            -X PATCH \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            ${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/issues/comments/${COMMENT_ID} \
            -d "{\"body\":\"${msg}\"}" | \
          jq -r '.html_url'

          # いらないファイル・ディレクトリの削除
          rm -rf ${tmp_capture_dir} ${tmp_json_file}
        done

        # シンボリックリンクの削除（etrobo環境で実行）
        echo 'unlink ${ETROBO_HRP3_WORKSPACE}/${{ env.APP_NAME }}' | ${HOME}/startetrobo shell

